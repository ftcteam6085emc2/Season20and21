package org.firstinspires.ftc.teamcode;

import android.media.MediaPlayer;
import android.graphics.Color;

import com.qualcomm.hardware.rev.RevBlinkinLedDriver;
import com.qualcomm.robotcore.eventloop.opmode.OpMode;
import com.qualcomm.robotcore.eventloop.opmode.TeleOp;
import com.qualcomm.robotcore.hardware.DcMotor;
import com.qualcomm.robotcore.util.ElapsedTime;
import com.qualcomm.robotcore.hardware.NormalizedColorSensor;
import com.qualcomm.robotcore.hardware.NormalizedRGBA;
import com.qualcomm.robotcore.hardware.SwitchableLight;

@TeleOp(name="NathanChassis", group="Test")
public class NathanChassis extends OpMode {
    
    private ElapsedTime     runtime = new ElapsedTime();

    static final double     COUNTS_PER_MOTOR_REV    = 1200 ;    // eg: TETRIX Motor Encoder
    static final double     DRIVE_GEAR_REDUCTION    = 1.0 ;     // This is < 1.0 if geared UP
    static final double     WHEEL_DIAMETER_INCHES   = 4.0 ;     // For figuring circumference
    static final double     COUNTS_PER_INCH         = (COUNTS_PER_MOTOR_REV * DRIVE_GEAR_REDUCTION) /
                                                      (WHEEL_DIAMETER_INCHES * 3.1415);
    //static final double     COUNTS_PER_INCH         = 1200 ;                                                      
    
    
    
    static final double     DRIVE_SPEED             = 0.6;
    static final double     TURN_SPEED              = 0.5;
    
    HWMap robot = new HWMap();


    @Override
    public void init() {
        robot.init(hardwareMap);
        robot.FrontRight.setZeroPowerBehavior(DcMotor.ZeroPowerBehavior.BRAKE);
        robot.FrontLeft.setZeroPowerBehavior(DcMotor.ZeroPowerBehavior.BRAKE);
        robot.RearRight.setZeroPowerBehavior(DcMotor.ZeroPowerBehavior.BRAKE);
        robot.RearLeft.setZeroPowerBehavior(DcMotor.ZeroPowerBehavior.BRAKE);
        // If possible, turn the light on in the beginning (it might already be on anyway,
        // we just make sure it is if we can).
        if (robot.colorSensor instanceof SwitchableLight) {
            ((SwitchableLight)robot.colorSensor).enableLight(true);
        }
        if (robot.colorSensor instanceof SwitchableLight) {
            SwitchableLight light = (SwitchableLight)robot.colorSensor;
            light.enableLight(!light.isLightOn());
          }
    }

    @Override
    public void loop() {

        robot.FrontLeft.setPower(gamepad1.left_stick_y - gamepad1.left_stick_x);
        robot.RearLeft.setPower(gamepad1.left_stick_y + gamepad1.left_stick_x);

        robot.FrontRight.setPower(-gamepad1.right_stick_y - gamepad1.right_stick_x);
        robot.RearRight.setPower(-gamepad1.right_stick_y + gamepad1.right_stick_x);

        if(gamepad1.a){
            //DriveStraightDistance(1000, 0.8);
            //robot.FrontRight.setMode(DcMotor.RunMode.STOP_AND_RESET_ENCODER);
            //robot.FrontLeft.setMode(DcMotor.RunMode.STOP_AND_RESET_ENCODER);
            //robot.RearRight.setMode(DcMotor.RunMode.STOP_AND_RESET_ENCODER);
            //robot.RearLeft.setMode(DcMotor.RunMode.STOP_AND_RESET_ENCODER);

            //encoderDrive(1, 70, 100, 25);
            DriveStraightDistance(2400, 0.4);
        
            telemetry.addData("RightCurrentPosition", robot.FrontRight.getCurrentPosition());
            telemetry.addData("LeftCurrentPosition", robot.FrontLeft.getCurrentPosition());
            telemetry.update();
        }
        NormalizedRGBA colors = robot.colorSensor.getNormalizedColors();
        telemetry.addLine()
              .addData("white", "%.3f", colors.alpha)
              .addData("red", "%.3f", colors.red)
              .addData("green", "%.3f", colors.green)
              .addData("blue", "%.3f", colors.blue);
        int color = colors.toColor();
         float max = Math.max(Math.max(Math.max(colors.red, colors.green), colors.blue), colors.alpha);
        colors.red   /= max;
        colors.green /= max;
        colors.blue  /= max;
        color = colors.toColor();

        telemetry.addLine("normalized color:  ")
              .addData("a", "%02x", Color.alpha(color))
              .addData("r", "%02x", Color.red(color))
              .addData("g", "%02x", Color.green(color))
              .addData("b", "%02x", Color.blue(color));
        telemetry.update();
        
    }
    
    private void DriveStraightDistance(int distance, double power){
        telemetry.addData("Driving", "Yes");
        
        robot.FrontRight.setMode(DcMotor.RunMode.STOP_AND_RESET_ENCODER);
        robot.FrontLeft.setMode(DcMotor.RunMode.STOP_AND_RESET_ENCODER);
        robot.RearRight.setMode(DcMotor.RunMode.STOP_AND_RESET_ENCODER);
        robot.RearLeft.setMode(DcMotor.RunMode.STOP_AND_RESET_ENCODER);
        
        robot.FrontRight.setMode(DcMotor.RunMode.RUN_TO_POSITION);
        robot.FrontLeft.setMode(DcMotor.RunMode.RUN_TO_POSITION);
        robot.RearRight.setMode(DcMotor.RunMode.RUN_TO_POSITION);
        robot.RearLeft.setMode(DcMotor.RunMode.RUN_TO_POSITION);

        robot.FrontRight.setTargetPosition(distance);
        robot.FrontLeft.setTargetPosition(-distance);
        robot.RearRight.setTargetPosition(distance);
        robot.RearLeft.setTargetPosition(-distance);

        DriveStraight(power);
        while(robot.FrontRight.isBusy() && robot.RearLeft.isBusy() && robot.RearRight.isBusy() && robot.FrontLeft.isBusy())
        {
            NormalizedRGBA colors = robot.colorSensor.getNormalizedColors();
            int color = colors.toColor();
            
            //if (Color.alpha(color) >= 6)
              if (Color.blue(color)  >= 60)
                break;
                
        }

        
               
                
        StopDriving();
        robot.FrontRight.setMode(DcMotor.RunMode.RUN_WITHOUT_ENCODER);
        robot.FrontLeft.setMode(DcMotor.RunMode.RUN_WITHOUT_ENCODER);
        robot.RearRight.setMode(DcMotor.RunMode.RUN_WITHOUT_ENCODER);
        robot.RearLeft.setMode(DcMotor.RunMode.RUN_WITHOUT_ENCODER);
    }

    private void DriveStraight(double power){
        /*if(strafeCancel){
            robot.FrontRight.setPower(power - 0.2);
            robot.FrontLeft.setPower(-power);
            robot.RearRight.setPower(power);
            robot.RearLeft.setPower(-power - 0.2);
        }
        else {*/
        robot.RearLeft.setPower(power);
        robot.RearRight.setPower(power);
        robot.FrontRight.setPower(power);
        robot.FrontLeft.setPower(power);
        //}
    }

    private void StopDriving (){DriveStraight(0);}
    
}
