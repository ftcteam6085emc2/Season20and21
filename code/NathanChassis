package org.firstinspires.ftc.teamcode;

import android.media.MediaPlayer;
import android.graphics.Color;

import com.qualcomm.hardware.rev.RevBlinkinLedDriver;
import com.qualcomm.robotcore.eventloop.opmode.OpMode;
import com.qualcomm.robotcore.eventloop.opmode.TeleOp;
import com.qualcomm.robotcore.hardware.DcMotor;
import com.qualcomm.robotcore.util.ElapsedTime;
import com.qualcomm.robotcore.hardware.NormalizedColorSensor;
import com.qualcomm.robotcore.hardware.NormalizedRGBA;
import com.qualcomm.robotcore.hardware.SwitchableLight;

@TeleOp(name="NathanChassis", group="Test")
public class NathanChassis extends OpMode {
    
    private ElapsedTime     runtime = new ElapsedTime();

    static final double     COUNTS_PER_MOTOR_REV    = 1200 ;    // eg: TETRIX Motor Encoder
    static final double     DRIVE_GEAR_REDUCTION    = 1.0 ;     // This is < 1.0 if geared UP
    static final double     WHEEL_DIAMETER_INCHES   = 4.0 ;     // For figuring circumference
    static final double     COUNTS_PER_INCH         = (COUNTS_PER_MOTOR_REV * DRIVE_GEAR_REDUCTION) /
                                                      (WHEEL_DIAMETER_INCHES * 3.1415);
    //static final double     COUNTS_PER_INCH         = 1200 ;                                                      
    
    
    
    static final double     DRIVE_SPEED             = 0.6;
    static final double     TURN_SPEED              = 0.5;
    
    HWMap robot = new HWMap();


    @Override
    public void init() {
        robot.init(hardwareMap);
        robot.FrontRight.setZeroPowerBehavior(DcMotor.ZeroPowerBehavior.BRAKE);
        robot.FrontLeft.setZeroPowerBehavior(DcMotor.ZeroPowerBehavior.BRAKE);
        robot.RearRight.setZeroPowerBehavior(DcMotor.ZeroPowerBehavior.BRAKE);
        robot.RearLeft.setZeroPowerBehavior(DcMotor.ZeroPowerBehavior.BRAKE);
        // If possible, turn the light on in the beginning (it might already be on anyway,
        // we just make sure it is if we can).
        if (robot.colorSensor instanceof SwitchableLight) {
            ((SwitchableLight)robot.colorSensor).enableLight(true);
        }
        if (robot.colorSensor instanceof SwitchableLight) {
            SwitchableLight light = (SwitchableLight)robot.colorSensor;
            light.enableLight(!light.isLightOn());
          }
    }

    @Override
    public void loop() {

        robot.FrontLeft.setPower(gamepad1.left_stick_y - gamepad1.left_stick_x);
        robot.RearLeft.setPower(gamepad1.left_stick_y + gamepad1.left_stick_x);

        robot.FrontRight.setPower(-gamepad1.right_stick_y - gamepad1.right_stick_x);
        robot.RearRight.setPower(-gamepad1.right_stick_y + gamepad1.right_stick_x);

        if(gamepad1.a){
            //DriveStraightDistance(1000, 0.8);
            //robot.FrontRight.setMode(DcMotor.RunMode.STOP_AND_RESET_ENCODER);
            //robot.FrontLeft.setMode(DcMotor.RunMode.STOP_AND_RESET_ENCODER);
            //robot.RearRight.setMode(DcMotor.RunMode.STOP_AND_RESET_ENCODER);
            //robot.RearLeft.setMode(DcMotor.RunMode.STOP_AND_RESET_ENCODER);

            //encoderDrive(1, 70, 100, 25);
            DriveStraightDistance(1200, 0.2);
        
            telemetry.addData("RightCurrentPosition", robot.FrontRight.getCurrentPosition());
            telemetry.addData("LeftCurrentPosition", robot.FrontLeft.getCurrentPosition());
            telemetry.update();
        }
        NormalizedRGBA colors = robot.colorSensor.getNormalizedColors();
        telemetry.addLine()
              .addData("a", "%.3f", colors.alpha)
              .addData("r", "%.3f", colors.red)
              .addData("g", "%.3f", colors.green)
              .addData("b", "%.3f", colors.blue);
        int color = colors.toColor();
         float max = Math.max(Math.max(Math.max(colors.red, colors.green), colors.blue), colors.alpha);
        colors.red   /= max;
        colors.green /= max;
        colors.blue  /= max;
        color = colors.toColor();

        telemetry.addLine("normalized color:  ")
              .addData("a", "%02x", Color.alpha(color))
              .addData("r", "%02x", Color.red(color))
              .addData("g", "%02x", Color.green(color))
              .addData("b", "%02x", Color.blue(color));
        telemetry.update();

    }

    private void DriveStraightDistance(int distance, double power){
        telemetry.addData("Driving", "Yes");
        robot.FrontRight.setMode(DcMotor.RunMode.STOP_AND_RESET_ENCODER);
        robot.FrontLeft.setMode(DcMotor.RunMode.STOP_AND_RESET_ENCODER);
        robot.RearRight.setMode(DcMotor.RunMode.STOP_AND_RESET_ENCODER);
        robot.RearLeft.setMode(DcMotor.RunMode.STOP_AND_RESET_ENCODER);
        
        robot.FrontRight.setMode(DcMotor.RunMode.RUN_TO_POSITION);
        robot.FrontLeft.setMode(DcMotor.RunMode.RUN_TO_POSITION);
        robot.RearRight.setMode(DcMotor.RunMode.RUN_TO_POSITION);
        robot.RearLeft.setMode(DcMotor.RunMode.RUN_TO_POSITION);

        robot.FrontRight.setTargetPosition(distance);
        robot.FrontLeft.setTargetPosition(-distance);
        robot.RearRight.setTargetPosition(distance);
        robot.RearLeft.setTargetPosition(-distance);

        DriveStraight(power);
        while((robot.FrontRight.isBusy() && robot.RearLeft.isBusy() && robot.RearRight.isBusy() && robot.FrontLeft.isBusy()));

        StopDriving();
        robot.FrontRight.setMode(DcMotor.RunMode.RUN_WITHOUT_ENCODER);
        robot.FrontLeft.setMode(DcMotor.RunMode.RUN_WITHOUT_ENCODER);
        robot.RearRight.setMode(DcMotor.RunMode.RUN_WITHOUT_ENCODER);
        robot.RearLeft.setMode(DcMotor.RunMode.RUN_WITHOUT_ENCODER);
    }

    private void DriveStraight(double power){
        /*if(strafeCancel){
            robot.FrontRight.setPower(power - 0.2);
            robot.FrontLeft.setPower(-power);
            robot.RearRight.setPower(power);
            robot.RearLeft.setPower(-power - 0.2);
        }
        else {*/
        robot.FrontRight.setPower(-power);
        robot.FrontLeft.setPower(power);
        robot.RearRight.setPower(-power);
        robot.RearLeft.setPower(power);
        //}
    }

    private void StopDriving (){DriveStraight(0);}
    
    public void encoderDrive(double speed,
                             double leftInches, double rightInches,
                             double timeoutS) {
        int newLeftTarget;
        int newRightTarget;

        // Ensure that the opmode is still active
        //if (opModeIsActive()) {
             if (true) {

            // Determine new target position, and pass to motor controller
            newLeftTarget = robot.FrontLeft.getCurrentPosition() + (int)(-leftInches * COUNTS_PER_INCH);
            newRightTarget = robot.FrontRight.getCurrentPosition() + (int)(rightInches * COUNTS_PER_INCH);
            robot.FrontLeft.setTargetPosition(newLeftTarget);
            robot.FrontRight.setTargetPosition(newRightTarget);
            robot.RearLeft.setTargetPosition(newLeftTarget);
            robot.RearRight.setTargetPosition(newRightTarget);

            // Turn On RUN_TO_POSITION
            robot.FrontLeft.setMode(DcMotor.RunMode.RUN_TO_POSITION);
            robot.FrontRight.setMode(DcMotor.RunMode.RUN_TO_POSITION);
            robot.RearLeft.setMode(DcMotor.RunMode.RUN_TO_POSITION);
            robot.RearRight.setMode(DcMotor.RunMode.RUN_TO_POSITION);

            // reset the timeout time and start motion.
            runtime.reset();
            robot.FrontLeft.setPower(Math.abs(speed));
            robot.FrontRight.setPower(Math.abs(speed));
            robot.RearLeft.setPower(Math.abs(speed));
            robot.RearRight.setPower(Math.abs(speed));

            // keep looping while we are still active, and there is time left, and both motors are running.
            // Note: We use (isBusy() && isBusy()) in the loop test, which means that when EITHER motor hits
            // its target position, the motion will stop.  This is "safer" in the event that the robot will
            // always end the motion as soon as possible.
            // However, if you require that BOTH motors have finished their moves before the robot continues
            // onto the next step, use (isBusy() || isBusy()) in the loop test.
            while (true &&
                   (runtime.seconds() < timeoutS) &&
                   (robot.FrontLeft.isBusy() && robot.FrontRight.isBusy() && 
                   robot.RearLeft.isBusy() && robot.RearRight.isBusy())) {

                // Display it for the driver.
                telemetry.addData("Path1",  "Running to %7d :%7d", newLeftTarget,  newRightTarget);
                telemetry.addData("Path2",  "Running at %7d :%7d",
                                            robot.FrontLeft.getCurrentPosition(),
                                            robot.FrontRight.getCurrentPosition());
                telemetry.update();
            }

            // Stop all motion;
            robot.FrontLeft.setPower(0);
            robot.FrontRight.setPower(0);
            robot.RearLeft.setPower(0);
            robot.RearRight.setPower(0);

            // Turn off RUN_TO_POSITION
            robot.FrontLeft.setMode(DcMotor.RunMode.RUN_USING_ENCODER);
            robot.FrontRight.setMode(DcMotor.RunMode.RUN_USING_ENCODER);
            robot.RearLeft.setMode(DcMotor.RunMode.RUN_USING_ENCODER);
            robot.RearRight.setMode(DcMotor.RunMode.RUN_USING_ENCODER);

            //  sleep(250);   // optional pause after each move
        }
    }
}
